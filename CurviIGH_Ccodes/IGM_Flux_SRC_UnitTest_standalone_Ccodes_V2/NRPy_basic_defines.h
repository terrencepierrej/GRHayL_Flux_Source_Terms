// NRPy+ basic definitions, automatically generated from outC_NRPy_basic_defines_h_dict within outputC,
//    and populated within NRPy+ modules. DO NOT EDIT THIS FILE BY HAND.



//********************************************
// Basic definitions for module outputC:

#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "string.h" // "string.h Needed for strncmp, etc.
#include "stdint.h" // "stdint.h" Needed for Windows GCC 6.x compatibility, and for int8_t

#ifndef M_PI
#define M_PI 3.141592653589793238462643383279502884L
#endif
#ifndef M_SQRT1_2
#define M_SQRT1_2 0.707106781186547524400844362104849039L
#endif

#ifndef MIN
#define MIN(A, B) ( ((A) < (B)) ? (A) : (B) )
#endif
#ifndef MAX
#define MAX(A, B) ( ((A) > (B)) ? (A) : (B) )
#endif

#ifdef __cplusplus
#define restrict __restrict__
#endif
#define REAL double
//********************************************


//********************************************
// Basic definitions for module NRPy_param_funcs:
typedef struct __paramstruct__ {
  REAL GAMMA_SPEED_LIMIT;  // GRMHD_equations_new_version::GAMMA_SPEED_LIMIT
  REAL dxx0;  // grid::dxx0
  REAL dxx1;  // grid::dxx1
  REAL dxx2;  // grid::dxx2
  REAL invdx0;  // grid::invdx0
  REAL invdx1;  // grid::invdx1
  REAL invdx2;  // grid::invdx2
  REAL sqrt4pi;  // GRMHD_equations_new_version::sqrt4pi
  REAL xmax;  // reference_metric::xmax
  REAL xmin;  // reference_metric::xmin
  REAL xx0;  // grid::xx0
  REAL xx1;  // grid::xx1
  REAL xx2;  // grid::xx2
  REAL ymax;  // reference_metric::ymax
  REAL ymin;  // reference_metric::ymin
  REAL zmax;  // reference_metric::zmax
  REAL zmin;  // reference_metric::zmin
  int Nxx0;  // grid::Nxx0
  int Nxx1;  // grid::Nxx1
  int Nxx2;  // grid::Nxx2
  int Nxx_plus_2NGHOSTS0;  // grid::Nxx_plus_2NGHOSTS0
  int Nxx_plus_2NGHOSTS1;  // grid::Nxx_plus_2NGHOSTS1
  int Nxx_plus_2NGHOSTS2;  // grid::Nxx_plus_2NGHOSTS2
} paramstruct;
//********************************************


//********************************************
// Basic definitions for module finite_difference:

// Set the number of ghost zones
// Note that upwinding in e.g., BSSN requires that NGHOSTS = FD_CENTDERIVS_ORDER/2 + 1 <- Notice the +1.
#define NGHOSTS 3
//********************************************


//********************************************
// Basic definitions for module reference_metric:
//********************************************


//********************************************
// Basic definitions for module grid:
// EVOLVED VARIABLES:
#define NUM_EVOL_GFS 5
#define STILDED0GF	0
#define STILDED1GF	1
#define STILDED2GF	2
#define RHO_STARGF	3
#define TAU_TILDEGF	4


// AUXILIARY VARIABLES:
#define NUM_AUX_GFS 0


// AUXEVOL VARIABLES:
#define NUM_AUXEVOL_GFS 106
#define BU0GF	0
#define BU1GF	1
#define BU2GF	2
#define B_LU0GF	3
#define B_LU1GF	4
#define B_LU2GF	5
#define B_RU0GF	6
#define B_RU1GF	7
#define B_RU2GF	8
#define GAMMA_TH_LGF	9
#define GAMMA_TH_RGF	10
#define HLLE_FLUX_STILDED0GF	11
#define HLLE_FLUX_STILDED1GF	12
#define HLLE_FLUX_STILDED2GF	13
#define HLLE_FLUX_RHO_STARGF	14
#define HLLE_FLUX_TAU_TILDEGF	15
#define KDD00GF	16
#define KDD01GF	17
#define KDD02GF	18
#define KDD11GF	19
#define KDD12GF	20
#define KDD22GF	21
#define PGF	22
#define P_LGF	23
#define P_RGF	24
#define VU0GF	25
#define VU1GF	26
#define VU2GF	27
#define V_LU0GF	28
#define V_LU1GF	29
#define V_LU2GF	30
#define V_RU0GF	31
#define V_RU1GF	32
#define V_RU2GF	33
#define ALPHAGF	34
#define ALPHA_DD0GF	35
#define ALPHA_DD1GF	36
#define ALPHA_DD2GF	37
#define ALPHA_FACEGF	38
#define BETAU0GF	39
#define BETAU1GF	40
#define BETAU2GF	41
#define BETAU_DD00GF	42
#define BETAU_DD01GF	43
#define BETAU_DD02GF	44
#define BETAU_DD10GF	45
#define BETAU_DD11GF	46
#define BETAU_DD12GF	47
#define BETAU_DD20GF	48
#define BETAU_DD21GF	49
#define BETAU_DD22GF	50
#define BETA_FACEU0GF	51
#define BETA_FACEU1GF	52
#define BETA_FACEU2GF	53
#define DPCOLD_DRHOB_LGF	54
#define DPCOLD_DRHOB_RGF	55
#define EPSILON_TH_LGF	56
#define EPSILON_TH_RGF	57
#define GAMMADD00GF	58
#define GAMMADD01GF	59
#define GAMMADD02GF	60
#define GAMMADD11GF	61
#define GAMMADD12GF	62
#define GAMMADD22GF	63
#define GAMMADD_DD000GF	64
#define GAMMADD_DD001GF	65
#define GAMMADD_DD002GF	66
#define GAMMADD_DD010GF	67
#define GAMMADD_DD011GF	68
#define GAMMADD_DD012GF	69
#define GAMMADD_DD020GF	70
#define GAMMADD_DD021GF	71
#define GAMMADD_DD022GF	72
#define GAMMADD_DD110GF	73
#define GAMMADD_DD111GF	74
#define GAMMADD_DD112GF	75
#define GAMMADD_DD120GF	76
#define GAMMADD_DD121GF	77
#define GAMMADD_DD122GF	78
#define GAMMADD_DD220GF	79
#define GAMMADD_DD221GF	80
#define GAMMADD_DD222GF	81
#define GAMMA_FACEDD00GF	82
#define GAMMA_FACEDD01GF	83
#define GAMMA_FACEDD02GF	84
#define GAMMA_FACEDD11GF	85
#define GAMMA_FACEDD12GF	86
#define GAMMA_FACEDD22GF	87
#define HGF	88
#define H_LGF	89
#define H_RGF	90
#define RHOBGF	91
#define RHOB_LGF	92
#define RHOB_RGF	93
#define U4U0GF	94
#define U4U1GF	95
#define U4U2GF	96
#define U4U3GF	97
#define U4_LU0GF	98
#define U4_LU1GF	99
#define U4_LU2GF	100
#define U4_LU3GF	101
#define U4_RU0GF	102
#define U4_RU1GF	103
#define U4_RU2GF	104
#define U4_RU3GF	105


// Declare the IDX4S(gf,i,j,k) macro, which enables us to store 4-dimensions of
//   data in a 1D array. In this case, consecutive values of "i"
//   (all other indices held to a fixed value) are consecutive in memory, where
//   consecutive values of "j" (fixing all other indices) are separated by
//   Nxx_plus_2NGHOSTS0 elements in memory. Similarly, consecutive values of
//   "k" are separated by Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1 in memory, etc.
#define IDX4S(g,i,j,k)                                                  \
  ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) + Nxx_plus_2NGHOSTS2 * (g) ) ) )
#define IDX4ptS(g,idx) ( (idx) + (Nxx_plus_2NGHOSTS0*Nxx_plus_2NGHOSTS1*Nxx_plus_2NGHOSTS2) * (g) )
#define IDX3S(i,j,k) ( (i) + Nxx_plus_2NGHOSTS0 * ( (j) + Nxx_plus_2NGHOSTS1 * ( (k) ) ) )
#define LOOP_REGION(i0min,i0max, i1min,i1max, i2min,i2max)              \
  for(int i2=i2min;i2<i2max;i2++) for(int i1=i1min;i1<i1max;i1++) for(int i0=i0min;i0<i0max;i0++)
#define LOOP_OMP(__OMP_PRAGMA__, i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max) _Pragma(__OMP_PRAGMA__) \
    for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_NOOMP(i0,i0min,i0max, i1,i1min,i1max, i2,i2min,i2max)      \
  for(int (i2)=(i2min);(i2)<(i2max);(i2)++) for(int (i1)=(i1min);(i1)<(i1max);(i1)++) for(int (i0)=(i0min);(i0)<(i0max);(i0)++)
#define LOOP_BREAKOUT(i0,i1,i2, i0max,i1max,i2max) i0=(i0max); i1=(i1max); i2=(i2max); break;
#define IS_IN_GRID_INTERIOR(i0i1i2, Nxx_plus_2NGHOSTS0,Nxx_plus_2NGHOSTS1,Nxx_plus_2NGHOSTS2, NG) \
  ( i0i1i2[0] >= (NG) && i0i1i2[0] < (Nxx_plus_2NGHOSTS0)-(NG) &&       \
    i0i1i2[1] >= (NG) && i0i1i2[1] < (Nxx_plus_2NGHOSTS1)-(NG) &&       \
    i0i1i2[2] >= (NG) && i0i1i2[2] < (Nxx_plus_2NGHOSTS2)-(NG) )

typedef struct __griddata__ {
  paramstruct params;
  REAL *restrict xx[3];
} griddata_struct;
//********************************************


//#ifndef TINYDOUBLE
static const double TINYDOUBLE = 1e-100;
//#endif

//#ifndef sqrt4pi
static const double sqrt4pi = 3.544907701811032054596334966682290365L;
//#endif

static const int kronecker_delta[4][3] = { { 0,0,0 },
                                    { 1,0,0 },
                                    { 0,1,0 },
                                    { 0,0,1 } };

/*
   The struct reconstructed_prims_struct contains variables for storing the (point-wise)
   reconstructed primitive variables. The struct elements are detailed below:
   
 --rhob: the baryonic density
 
 --P: the pressure
 
 --u4U*: the contravariant fluid 4-velocity
   
 --BU*: the contravariant magnetic field
 
 --h: the enthalpy
 
 --Gamma_th: an EOS quantity
 
 --epsilon_th: an EOS quantity
 
 --dPcold_drhob: an EOS quantity
*/

typedef struct __reconstructed_prims__ {
double u4U0, u4U1, u4U2, u4U3;
double BU0, BU1, BU2;
double rhob;
double P, h, Gamma_th, epsilon_th, dPcold_drhob;
} reconstructed_prims_struct;


/*
   Parameters used throughout the module. The struct elements are detailed below:
 
 --TINYDOUBLE: tiny double to avoid divide by zero issues
 
 --sqrt4pi: \sqrt{4\pi} to 16 S.D.
*/

/*
typedef struct __rhss_params__ {
double TINYDOUBLE, sqrt4pi;
} rhss_params_struct;
*/


/*
   The struct conservative_fluxes_struct contains variables for HLLE fluxes that the user
   will finite difference later. Note that we do not store the fluxes for all three
   directions. The struct elements are detailed below:
   
 --cmin* / cmax*: the minimum and maximum characteristic speeds for all three flux directions
 
 --HLLE_flux_StildeD*: the HLLE flux for the momentum term term, all three components
 
 --HLLE_flux_rho_star: the HLLE flux for the baryonic density
   
 --HLLE_flux_tau_tilde: the HLLE flux for the energy
*/

typedef struct __conservative_fluxes__ {
double cmin_dirn0, cmin_dirn1, cmin_dirn2;
double cmax_dirn0, cmax_dirn1, cmax_dirn2;
double HLLE_flux_StildeD0, HLLE_flux_StildeD1, HLLE_flux_StildeD2;
double HLLE_flux_rho_star, HLLE_flux_tau_tilde;
} conservative_fluxes_struct;


/*
   The struct conservative_sources_struct contains stores the point-wise values 
   of the source terms for the momentum and energy equations. The struct 
   elements are detailed below:
   
 --StildeD*_src: momentum equations source terms
 
 --tau_tilde_src: tau equation source term
*/

typedef struct __conservative_sources__ {
double StildeD0_src, StildeD1_src, StildeD2_src;
double tau_tilde_src;
} conservative_sources_struct;



/*
   The struct metric_quantities_struct contains variables for storing the (point-wise)
   metric variables. The struct elements are detailed below:
   
 --alpha: the lapse
 
 --betaU*: the shift vector
   
 --gammaDD**: the physical 3-metric
 
 --KDD*: the extrinsic curvature
*/

typedef struct __metric_quantities__ {
double alpha;
double betaU0, betaU1, betaU2;
double gammaDD01, gammaDD02, gammaDD12, gammaDD00, gammaDD11, gammaDD22;
double KDD01, KDD02, KDD12, KDD00, KDD11, KDD22;
} metric_quantities_struct;


/*
   The struct metric_face_quantities_struct contains metric quantities stored on grid faces.
*/

typedef struct __metric_face_quantities__ {
double alpha_face;
double beta_faceU0, beta_faceU1, beta_faceU2;
double gamma_faceDD01, gamma_faceDD02, gamma_faceDD12, gamma_faceDD00, gamma_faceDD11, gamma_faceDD22;
} metric_face_quantities_struct;


/*
   The struct metric_quantities_derivatives_struct contains variables for
   precomputed derivatives of the metric quantities.
*/

typedef struct __metric_quantities_derivatives__ {
double alpha_dD1;
double gammaDD_dD111;
double alpha_dD2;
double betaU_dD12;
double gammaDD_dD020;
double gammaDD_dD122;
double gammaDD_dD001;
double gammaDD_dD022;
double gammaDD_dD121;
double alpha_dD0;
double betaU_dD10;
double betaU_dD01;
double gammaDD_dD110;
double betaU_dD00;
double betaU_dD22;
double gammaDD_dD221;
double gammaDD_dD112;
double gammaDD_dD021;
double betaU_dD21;
double betaU_dD20;
double gammaDD_dD012;
double betaU_dD02;
double gammaDD_dD222;
double gammaDD_dD220;
double gammaDD_dD010;
double betaU_dD11;
double gammaDD_dD002;
double gammaDD_dD000;
double gammaDD_dD120;
double gammaDD_dD011;

} metric_quantities_derivatives_struct;

